# Проанализировать скорость и сложность одного любого алгоритма из разработанных в рамках домашнего задания первых трех уроков.
# Примечание. Идеальным решением будет:
# ● выбрать хорошую задачу, которую имеет смысл оценивать,
# ● написать 3 варианта кода (один у вас уже есть),
# ● проанализировать 3 варианта и выбрать оптимальный,
# ● результаты анализа вставить в виде комментариев в файл с кодом (не забудьте указать, для каких N вы проводили замеры),
# ● написать общий вывод: какой из трёх вариантов лучше и почему.
import timeit
import cProfile

# Задача:
#Сформировать из введенного числа обратное по порядку входящих в него цифр и вывести на экран.
# Например, если введено число 3486, надо вывести 6843.

# 1. вариант - цикл
def loop(n):
    rez = 0
    while n > 0:
        rez = rez*10 + n % 10
        n = n // 10
    return (rez)

# print(loop(11245457845456541124545784545654112454578454565411245457845456541124545784545654112454578454565411245457845456541124545784545654))

print(timeit.timeit('loop(14555455)', number=100000, globals=globals()))                 # 0.4215038
print(timeit.timeit('loop(1124545784545654)', number=100000, globals=globals()))                # 0.9469804999999999
print(timeit.timeit('loop(11245457845456541124545784545654)', number=100000, globals=globals()))              # 2.2849872
print(timeit.timeit('loop(1124545784545654112454578454565411245457845456541124545784545654)', number=100000, globals=globals()))          # 4.7622757
print(timeit.timeit('loop(11245457845456541124545784545654112454578454565411245457845456541124545784545654112454578454565411245457845456541124545784545654)', number=100000, globals=globals()))  # 10.274329500000002

cProfile.run('loop(1)')  # 1    0.000    0.000    0.000    0.000 Les_4_Task_1.py:16(loop)
cProfile.run('loop(12)')  #  1    0.000    0.000    0.000    0.000 Les_4_Task_1.py:16(loop)
cProfile.run('loop(1234)')  # 1    0.000    0.000    0.000    0.000 Les_4_Task_1.py:16(loop)
cProfile.run('loop(12345678)')  #   1    0.000    0.000    0.000    0.000 Les_4_Task_1.py:16(loop)

# 2 вариант - рекурсивный

def recur(n):
    s = ''
    if n // 10 < 1:
        return(str(n))
    else:
        return(s + str(n % 10) + recur(n // 10))

# print(recur(12345678))


print(timeit.timeit('recur(14555455)', number=100000, globals=globals()))                 # 0.9319766
print(timeit.timeit('recur(1455545514555455)', number=100000, globals=globals()))                # 2.0513293
print(timeit.timeit('recur(14555455145554551455545514555455)', number=100000, globals=globals()))              # 3.5167559999999995
print(timeit.timeit('recur(1455545514555455145554551455545514555455145554551455545514555455)', number=100000, globals=globals()))          # 8.5196491
print(timeit.timeit('recur(14555455145554551455545514555455145554551455545514555455145554551455545514555455145554551455545514555455145554551455545514555455)', number=100000, globals=globals()))  # 19.1766243

cProfile.run('recur(14555455)')  #  8/1    0.000    0.000    0.000    0.000 Les_4_Task_1.py:38(recur)
cProfile.run('recur(1455545514555455)')  #  16/1    0.000    0.000    0.000    0.000 Les_4_Task_1.py:38(recur)
cProfile.run('recur(14555455145554551455545514555455)')  # 32/1    0.000    0.000    0.000    0.000 Les_4_Task_1.py:38(recur)
cProfile.run('recur(1455545514555455145554551455545514555455145554551455545514555455)')  #   64/1    0.000    0.000    0.000    0.000 Les_4_Task_1.py:38(recur)

def string_(n):
    s = str(n)
    if n > 9:
        return(s[::-1])
    else:
        return(s)

# print(string_(14555455145554551455545514555455145554551455545514555455145554551455545514555455145554551455545514555455145554551455545514555455))

print(timeit.timeit('string_(14555455)', number=100000, globals=globals()))                 # 0.0802754
print(timeit.timeit('string_(1455545514555455)', number=100000, globals=globals()))                # 0.09241150000000001
print(timeit.timeit('string_(14555455145554551455545514555455)', number=100000, globals=globals()))              # 0.1012737
print(timeit.timeit('string_(1455545514555455145554551455545514555455145554551455545514555455)', number=100000, globals=globals()))          # 0.13363219999999998
print(timeit.timeit('string_(14555455145554551455545514555455145554551455545514555455145554551455545514555455145554551455545514555455145554551455545514555455)', number=100000, globals=globals()))  # 0.24492509999999995

cProfile.run('string_(14555455)')  # 1    0.000    0.000    0.000    0.000 Les_4_Task_1.py:59(string)
cProfile.run('string_(1455545514555455)')  #  1    0.000    0.000    0.000    0.000 Les_4_Task_1.py:59(string)
cProfile.run('string_(14555455145554551455545514555455)')  # 1    0.000    0.000    0.000    0.000 Les_4_Task_1.py:59(string)
cProfile.run('string_(1455545514555455145554551455545514555455145554551455545514555455)')  #   1    0.000    0.000    0.000    0.000 Les_4_Task_1.py:59(string)

# Краткий анализ:
# Были проанализированы три разных алгоритма решения поставленной задачи: с использованием рекурсии,
# цикла и через подмену формата - число в виде строки. Алгоритмы тестировались на одинаковых входных данных,
# а именно на числах, состоящих из 8, 16, 32, 64 и 128 цифр. Анализ на основании эмперических данных показал,
# что наименее зависим от объема входных данных алгоритм с использованием строки
# (но он имеет ограничения на количество символов, то есть цифр, хотя на данном примере это не имело значения),
# время практически не изменяется в зависимости от объема входных данных, то есть практически константа
# (на графике можно проследить незначительное увеличение времени работы алгоритма с увеличением объема входящих данных)
# Второй по скорости работы алгоритм с использованием цикла - его зависимость можно описать линейно О(n), при этом,
# при увеличении объема входных данных в два раза - время так же увеличивается в два раза. Третий алгоритм с
# использованием рекурсивной функции - показал худший результат - при увеличении объема входных данных в два раза,
# время работы увеличивалось,  так же в два раза, но это время в среднем в два раза хуже предыдущего алгоритма
# (с использованием цикла), и на графике видно, что возрастание этой функции происходит быстрее, чем функции
# циклического алгоритма. Помимо этого рекурсивный алгоритм занимает больше памяти, так как функция вызывается не
# единожды (количество вызовов растет пропорционально росту входных данных).
# Графики зависимостей времени от входных данных можно посмотреть по ссылке:
# https://drive.google.com/file/d/1VlumpDprJg3L75Kloa8zWcEo73vC2hLy/view?usp=sharing